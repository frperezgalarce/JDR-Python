q()
## -----------------------------------------------------------
## JDR spectral divergence pipeline (correct + more robust)
## -----------------------------------------------------------
## 1) Load custom functions
source("cross.phase.spectrum.r")
source("cross.amplitude.spectrum.r")
source("amplitude.spectrum.r")
source("tau.r")
source("squared.coherence.spectrum.r")
source("phase.spectrum.r")
source("periodogram.phase.component.r")
source("periodogram.component.r")
source("cross.spectrum.r")
source("power.spectrum.r")
source("cross.spec.mtls.r")
## 2) Read light curves
Irrlyr1 <- read.delim("OGLE-BLG-RRLYR-00001.dat", sep = "")
Irrlyr2 <- read.delim("OGLE-BLG-RRLYR-00003.dat", sep = "")
plot(Irrlyr1[, 1], Irrlyr1[, 2], type = "o", main = "Series 1", xlab="time", ylab="mag")
plot(Irrlyr2[, 1], Irrlyr2[, 2], type = "o", main = "Series 2", xlab="time", ylab="mag")
## 3) Global spectral parameters
alpha <- 0.5
beta  <- alpha * (1 - alpha)
st <- Irrlyr1[, 1]
delta.t <- (max(st) - min(st)) / length(st)
delta.f <- 0.001
f.min <- delta.f
f.max <- 1 / (2 * delta.t)
cat(sprintf("delta.t=%.10f, f.min=%.6f, f.max=%.10f\n", delta.t, f.min, f.max))
## 4) Define time series
x   <- Irrlyr1[, 2]
st1 <- Irrlyr1[, 1]
y   <- Irrlyr2[, 2]
st2 <- Irrlyr2[, 1]
## Optional: remove NAs defensively (should not be needed if files are clean)
ok1 <- is.finite(st1) & is.finite(x)
ok2 <- is.finite(st2) & is.finite(y)
st1 <- st1[ok1]; x <- x[ok1]
st2 <- st2[ok2]; y <- y[ok2]
## 5) Wrapper: integrate over f, but cross.spectrum expects omega
cross_spectrum_f <- function(f, t1, x1, t2, x2, demeaned=FALSE, standardized=FALSE) {
  omega <- 2*pi*f
  cross.spectrum(t1, x1, t2, x2, omega, demeaned=demeaned, standardized=standardized)
}
## 6) Robust integration helper
safe_integrate <- function(fun, lower, upper, ..., rel.tol=1e-8, abs.tol=1e-8,
                           subdivisions=2000, stop.on.error=FALSE,
                           retry=2, fallback_grid=TRUE, grid_n=20001) {
  attempt <- function(rt, at, sub) {
    wtxt <- character(0)
    val <- withCallingHandlers(
      try(integrate(fun, lower=lower, upper=upper,
                    rel.tol=rt, abs.tol=at, subdivisions=sub,
                    stop.on.error=stop.on.error, ...),
          silent=TRUE),
      warning = function(w) {
        wtxt <<- c(wtxt, conditionMessage(w))
        invokeRestart("muffleWarning")
      }
    )
    list(res=val, warnings=wtxt, rt=rt, at=at, sub=sub)
  }
  rt <- rel.tol; at <- abs.tol; sub <- subdivisions
  out <- attempt(rt, at, sub)
  k <- 0
  while (k < retry &&
         (inherits(out$res, "try-error") || !is.list(out$res) || !is.finite(out$res$value))) {
    k <- k + 1
    rt <- max(rt, 10^(-8 + k))   # relax: 1e-8 -> 1e-7 -> 1e-6
    at <- max(at, 10^(-8 + k))
    sub <- max(sub, 2000 * (10^k))
    out <- attempt(rt, at, sub)
  }
  if (!inherits(out$res, "try-error") && is.list(out$res) && is.finite(out$res$value)) {
    if (length(out$warnings)) {
      cat("Warnings during integrate():\n")
      cat(paste0(" - ", unique(out$warnings), collapse="\n"), "\n")
    }
    return(out$res$value)
  }
  ## Fallback: trapezoid on dense grid (deterministic and often stable)
  if (fallback_grid) {
    fgrid <- seq(lower, upper, length.out=grid_n)
    ygrid <- fun(fgrid, ...)
    ## ygrid must be numeric vector
    if (any(!is.finite(ygrid))) stop("Fallback grid produced non-finite values.")
    dx <- (upper - lower) / (grid_n - 1)
    trap <- dx * (0.5*ygrid[1] + sum(ygrid[2:(grid_n-1)]) + 0.5*ygrid[grid_n])
    cat("integrate() failed; used trapezoid fallback on grid.\n")
    return(trap)
  }
  stop("safe_integrate(): integrate() failed and fallback_grid=FALSE.")
}
## 7) Evaluate spectra on a grid (optional diagnostics)
f_grid <- seq(f.min, f.max, by=delta.f)
omega_grid <- 2*pi*f_grid
sx1 <- cross.spectrum(st1, x, st1, x, omega_grid)
sx2 <- cross.spectrum(st2, y, st2, y, omega_grid)
## 8) Integrals (corrected)
Ix <- safe_integrate(
  cross_spectrum_f,
  lower=f.min, upper=f.max,
  t1=st1, x1=x, t2=st1, x2=x,
  demeaned=FALSE, standardized=FALSE,
  rel.tol=1e-8, abs.tol=1e-8, subdivisions=2000
)
Iy <- safe_integrate(
  cross_spectrum_f,
  lower=f.min, upper=f.max,
  t1=st2, x1=y, t2=st2, x2=y,
  demeaned=FALSE, standardized=FALSE,
  rel.tol=1e-8, abs.tol=1e-8, subdivisions=2000
)
f.max.xy <- min(f.max, f.max)  # kept for compatibility with your script
Ixy <- safe_integrate(
  cross_spectrum_f,
  lower=f.min, upper=f.max.xy,
  t1=st1, x1=x, t2=st2, x2=y,
  demeaned=FALSE, standardized=FALSE,
  rel.tol=1e-8, abs.tol=1e-8, subdivisions=4000
)
## 9) Jensen-type spectral divergence
J <- beta * (Ix + Iy - 2*Ixy) / (2*pi)
cat(sprintf("Ix=%.17g\nIy=%.17g\nIxy=%.17g\nJ=%.17g\n", Ix, Iy, Ixy, J))
J
q()
