  ## Fallback: trapezoid on dense grid (deterministic and often stable)
  if (fallback_grid) {
    fgrid <- seq(lower, upper, length.out=grid_n)
    ygrid <- fun(fgrid, ...)
    ## ygrid must be numeric vector
    if (any(!is.finite(ygrid))) stop("Fallback grid produced non-finite values.")
    dx <- (upper - lower) / (grid_n - 1)
    trap <- dx * (0.5*ygrid[1] + sum(ygrid[2:(grid_n-1)]) + 0.5*ygrid[grid_n])
    cat("integrate() failed; used trapezoid fallback on grid.\n")
    return(trap)
  }
  stop("safe_integrate(): integrate() failed and fallback_grid=FALSE.")
}
## 7) Evaluate spectra on a grid (optional diagnostics)
f_grid <- seq(f.min, f.max, by=delta.f)
omega_grid <- 2*pi*f_grid
sx1 <- cross.spectrum(st1, x, st1, x, omega_grid)
sx2 <- cross.spectrum(st2, y, st2, y, omega_grid)
## 8) Integrals (corrected)
Ix <- safe_integrate(
  cross_spectrum_f,
  lower=f.min, upper=f.max,
  t1=st1, x1=x, t2=st1, x2=x,
  demeaned=FALSE, standardized=FALSE,
  rel.tol=1e-8, abs.tol=1e-8, subdivisions=2000
)
Iy <- safe_integrate(
  cross_spectrum_f,
  lower=f.min, upper=f.max,
  t1=st2, x1=y, t2=st2, x2=y,
  demeaned=FALSE, standardized=FALSE,
  rel.tol=1e-8, abs.tol=1e-8, subdivisions=2000
)
f.max.xy <- min(f.max, f.max)  # kept for compatibility with your script
Ixy <- safe_integrate(
  cross_spectrum_f,
  lower=f.min, upper=f.max.xy,
  t1=st1, x1=x, t2=st2, x2=y,
  demeaned=FALSE, standardized=FALSE,
  rel.tol=1e-8, abs.tol=1e-8, subdivisions=4000
)
## 9) Jensen-type spectral divergence
J <- beta * (Ix + Iy - 2*Ixy) / (2*pi)
cat(sprintf("Ix=%.17g\nIy=%.17g\nIxy=%.17g\nJ=%.17g\n", Ix, Iy, Ixy, J))
J
## -----------------------------------------------------------
## JDR spectral divergence pipeline (correct + more robust)
## -----------------------------------------------------------
## 1) Load custom functions
source("cross.phase.spectrum.r")
source("cross.amplitude.spectrum.r")
source("amplitude.spectrum.r")
source("tau.r")
source("squared.coherence.spectrum.r")
source("phase.spectrum.r")
source("periodogram.phase.component.r")
source("periodogram.component.r")
source("cross.spectrum.r")
source("power.spectrum.r")
source("cross.spec.mtls.r")
## 2) Read light curves
Irrlyr1 <- read.delim("OGLE-BLG-RRLYR-00001.dat", sep = "")
Irrlyr2 <- read.delim("OGLE-BLG-RRLYR-00003.dat", sep = "")
plot(Irrlyr1[, 1], Irrlyr1[, 2], type = "o", main = "Series 1", xlab="time", ylab="mag")
plot(Irrlyr2[, 1], Irrlyr2[, 2], type = "o", main = "Series 2", xlab="time", ylab="mag")
## 3) Global spectral parameters
alpha <- 0.5
beta  <- alpha * (1 - alpha)
st <- Irrlyr1[, 1]
delta.t <- (max(st) - min(st)) / length(st)
delta.f <- 0.001
f.min <- delta.f
f.max <- 1 / (2 * delta.t)
cat(sprintf("delta.t=%.10f, f.min=%.6f, f.max=%.10f\n", delta.t, f.min, f.max))
## 4) Define time series
x   <- Irrlyr1[, 2]
st1 <- Irrlyr1[, 1]
y   <- Irrlyr2[, 2]
st2 <- Irrlyr2[, 1]
## Optional: remove NAs defensively (should not be needed if files are clean)
ok1 <- is.finite(st1) & is.finite(x)
ok2 <- is.finite(st2) & is.finite(y)
st1 <- st1[ok1]; x <- x[ok1]
st2 <- st2[ok2]; y <- y[ok2]
## 5) Wrapper: integrate over f, but cross.spectrum expects omega
cross_spectrum_f <- function(f, t1, x1, t2, x2, demeaned=FALSE, standardized=FALSE) {
  omega <- 2*pi*f
  cross.spectrum(t1, x1, t2, x2, omega, demeaned=demeaned, standardized=standardized)
}
## 6) Robust integration helper
safe_integrate <- function(fun, lower, upper, ..., rel.tol=1e-8, abs.tol=1e-8,
                           subdivisions=2000, stop.on.error=FALSE,
                           retry=2, fallback_grid=TRUE, grid_n=20001) {
  attempt <- function(rt, at, sub) {
    wtxt <- character(0)
    val <- withCallingHandlers(
      try(integrate(fun, lower=lower, upper=upper,
                    rel.tol=rt, abs.tol=at, subdivisions=sub,
                    stop.on.error=stop.on.error, ...),
          silent=FALSE),
      warning = function(w) {
        wtxt <<- c(wtxt, conditionMessage(w))
        invokeRestart("muffleWarning")
      }
    )
    list(res=val, warnings=wtxt, rt=rt, at=at, sub=sub)
  }
  rt <- rel.tol; at <- abs.tol; sub <- subdivisions
  print(c(rt, at, sub))
  out <- attempt(rt, at, sub)
  print(c(rt, at, sub))
  k <- 0
  while (k < retry &&
         (inherits(out$res, "try-error") || !is.list(out$res) || !is.finite(out$res$value))) {
    k <- k + 1
    rt <- max(rt, 10^(-8 + k))   # relax: 1e-8 -> 1e-7 -> 1e-6
    at <- max(at, 10^(-8 + k))
    sub <- max(sub, 2000 * (10^k))
    print(c(k, rt, at, sub))
    out <- attempt(rt, at, sub)
  }
  if (!inherits(out$res, "try-error") && is.list(out$res) && is.finite(out$res$value)) {
    if (length(out$warnings)) {
      cat("Warnings during integrate():\n")
      cat(paste0(" - ", unique(out$warnings), collapse="\n"), "\n")
    }
    return(out$res$value)
  }
  ## Fallback: trapezoid on dense grid (deterministic and often stable)
  if (fallback_grid) {
    fgrid <- seq(lower, upper, length.out=grid_n)
    ygrid <- fun(fgrid, ...)
    ## ygrid must be numeric vector
    if (any(!is.finite(ygrid))) stop("Fallback grid produced non-finite values.")
    dx <- (upper - lower) / (grid_n - 1)
    trap <- dx * (0.5*ygrid[1] + sum(ygrid[2:(grid_n-1)]) + 0.5*ygrid[grid_n])
    cat("integrate() failed; used trapezoid fallback on grid.\n")
    return(trap)
  }
  stop("safe_integrate(): integrate() failed and fallback_grid=FALSE.")
}
## 7) Evaluate spectra on a grid (optional diagnostics)
f_grid <- seq(f.min, f.max, by=delta.f)
omega_grid <- 2*pi*f_grid
sx1 <- cross.spectrum(st1, x, st1, x, omega_grid)
sx2 <- cross.spectrum(st2, y, st2, y, omega_grid)
## 8) Integrals (corrected)
Ix <- safe_integrate(
  cross_spectrum_f,
  lower=f.min, upper=f.max,
  t1=st1, x1=x, t2=st1, x2=x,
  demeaned=FALSE, standardized=FALSE,
  rel.tol=1e-8, abs.tol=1e-8, subdivisions=2000
)
Iy <- safe_integrate(
  cross_spectrum_f,
  lower=f.min, upper=f.max,
  t1=st2, x1=y, t2=st2, x2=y,
  demeaned=FALSE, standardized=FALSE,
  rel.tol=1e-8, abs.tol=1e-8, subdivisions=2000
)
f.max.xy <- min(f.max, f.max)  # kept for compatibility with your script
Ixy <- safe_integrate(
  cross_spectrum_f,
  lower=f.min, upper=f.max.xy,
  t1=st1, x1=x, t2=st2, x2=y,
  demeaned=FALSE, standardized=FALSE,
  rel.tol=1e-8, abs.tol=1e-8, subdivisions=4000
)
## 9) Jensen-type spectral divergence
J <- beta * (Ix + Iy - 2*Ixy) / (2*pi)
cat(sprintf("Ix=%.17g\nIy=%.17g\nIxy=%.17g\nJ=%.17g\n", Ix, Iy, Ixy, J))
J
integrate(cross_spectrum_f, 
  lower=f.min, upper=f.max,
  t1=st1, x1=x, t2=st1, x2=x,
 rel.tol=1e-8, abs.tol=1e-8, subdivisions=2000)
Ix <- safe_integrate(
  cross_spectrum_f,
  lower=f.min, upper=f.max,
  t1=st1, x1=x, t2=st1, x2=x,
  demeaned=FALSE, standardized=FALSE,
  rel.tol=1e-8, abs.tol=1e-8, subdivisions=2000
)
Ix
integrate(cross_spectrum_f, 
  lower=f.min, upper=f.max,
  t1=st1, x1=x, t2=st1, x2=x0)
integrate(cross_spectrum_f, 
  lower=f.min, upper=f.max,
  t1=st1, x1=x, t2=st1, x2=x)
## -----------------------------------------------------------
## Load custom functions for spectral and cross-spectral analysis
## (each of these .r files defines one or more functions used below)
## -----------------------------------------------------------
source("cross.phase.spectrum.r")          # functions for cross-phase spectrum
source("cross.amplitude.spectrum.r")      # functions for cross-amplitude spectrum
source("amplitude.spectrum.r")            # functions for (auto) amplitude spectrum
source("tau.r")                           # auxiliary function(s), e.g. lag/tau calculations
source("squared.coherence.spectrum.r")    # functions for squared coherence spectrum
source("phase.spectrum.r")                # functions for phase spectrum
source("periodogram.phase.component.r")   # functions for phase component of periodogram
source("periodogram.component.r")         # functions for periodogram of a single series
source("cross.spectrum.r")                # main cross-spectrum estimator for two series
source("power.spectrum.r")                # power spectrum / auto-spectrum functions
source("cross.spec.mtls.r")               # multitaper / MTLS-based cross-spectrum estimator
source("safe_integrate.r")
## -----------------------------------------------------------
## Load and plot the first light curve (irregularly sampled)
## -----------------------------------------------------------
Irrlyr1 <- read.delim("OGLE-BLG-RRLYR-00001.dat", sep = "")
# Irrlyr1 <- read.delim(OGLE-BLG-LPV-000009.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-BLG-LPV-000018.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-BLG-LPV-000024.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-CEP-0002.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-CEP-0005.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-CEP-0008.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-CEP-0011.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-RRLYR-00002.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-RRLYR-00003.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-RRLYR-00004.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-RRLYR-00005.dat", sep = "")
# Irrlyr1 is a data frame:
#   column 1: time (e.g. HJD or MJD)
#   column 2: magnitude
#   column 3: magnitude error
plot(Irrlyr1[, 1], Irrlyr1[, 2], type = "o")
# Quick visualization of the first RR Lyrae light curve:
# x-axis: time, y-axis: magnitude, points connected with lines ("o")
## -----------------------------------------------------------
## Load and plot the second light curve
## -----------------------------------------------------------
Irrlyr2 <- read.delim("OGLE-BLG-RRLYR-00003.dat", sep = "")
# Same structure as Irrlyr1 but for a second star (or band)
plot(Irrlyr2[, 1], Irrlyr2[, 2], type = "o")
# Visual check of the second series
## -----------------------------------------------------------
## Global spectral parameters: mixture weight and frequency grid
## -----------------------------------------------------------
alpha <- 0.5
# alpha is a mixing parameter used in Jensen-type spectral divergence
beta  <- alpha * (1 - alpha)
# beta = alpha * (1 - alpha) = 0.25 for alpha = 0.5
# This factor appears in the Jensen-type divergence between spectra
st <- Irrlyr1[, 1]
# st: time vector for series 1 (first light curve)
delta.t <- (sort(st)[length(st)] - sort(st)[1]) / length(st)
# Approximate average sampling interval Δt:
#   Δt ≈ (t_max - t_min) / N
# Using sorted times to get min and max
delta.f <- 0.001
# Frequency resolution / step Δf for evaluating the spectrum
f.min <- delta.f
# Smallest frequency evaluated: we start at Δf instead of 0
# (avoid the exact zero-frequency bin)
f.max <- 1 / (2 * delta.t)
# Maximum frequency f_max ≈ 1 / (2 * Δt) (Nyquist-like approximation)
f <- seq(f.min, f.max, delta.f)
# Frequency grid: f_min, f_min + Δf, ..., f_max
# This will be used for evaluating auto- and cross-spectra
omega <- 2 * pi * f
# Angular frequency grid: ω = 2πf
## -----------------------------------------------------------
## Define the two time series and approximate sampling
## -----------------------------------------------------------
# series 1
x   <- Irrlyr1[, 2]    # magnitudes of first light curve
st1 <- Irrlyr1[, 1]    # corresponding times of first light curve
delta.t1 <- (max(st1) - min(st1)) / length(st1)
# Approximate average sampling interval for series 1
# (not used directly below, but kept for completeness / diagnostics)
# series 2
y   <- Irrlyr2[, 2]    # magnitudes of second light curve
st2 <- Irrlyr2[, 1]    # corresponding times of second light curve
delta.t2 <- (max(st2) - min(st2)) / length(st2)
# Approximate average sampling interval for series 2
## -----------------------------------------------------------
## Auto-spectra (power or cross-spectrum with itself)
## -----------------------------------------------------------
sx1 <- cross.spectrum(st1, x, st1, x, omega)
# sx1: cross-spectrum of series 1 with itself (i.e. auto-spectrum)
# arguments:
#   t1 = st1, x1 = x -> first series
#   t2 = st1, x2 = x -> same series
#   omega         -> angular frequency grid
# Result is typically complex-valued as a function of ω
cross_spectrum_f <- function(f, t1, x1, t2, x2, demeaned=FALSE, standardized=FALSE) {
  omega <- 2*pi*f
  cross.spectrum(t1, x1, t2, x2, omega, demeaned=demeaned, standardized=standardized)
}
Ix <- integrate(
  cross_spectrum_f,
  lower = f.min,
  upper = f.max,
  t1    = st1, x1 = x,
  t2    = st1, x2 = x
)$value
# Ix: integral over frequency of the auto-spectrum of series 1
#   Ix = ∫_{f_min}^{f_max} S_xx(f) df
# Numerically computed via integrate(), using cross.spectrum as integrand.
sx2 <- cross.spectrum(st2, y, st2, y, omega)
# sx2: cross-spectrum of series 2 with itself (auto-spectrum for y)
Iy <- integrate(
  cross_spectrum_f,
  lower = f.min,
  upper = f.max,
  t1    = st2, x1 = y,
  t2    = st2, x2 = y
)$value
# Iy: integral over frequency of the auto-spectrum of series 2
#   Iy = ∫_{f_min}^{f_max} S_yy(f) df
## -----------------------------------------------------------
## Cross term: cross-spectrum between series 1 and 2
## -----------------------------------------------------------
f.max.xy <- min(f.max, f.max)
# Upper limit for the cross integral.
# Here min(f.max, f.max) is simply f.max; this line is equivalent to:
#   f.max.xy <- f.max
# (You could simplify to f.max.xy <- f.max.)
Ixy <- integrate(
  cross_spectrum_f,
  lower = f.min,
  upper = f.max.xy,
  t1    = st1, x1 = x,   # first series (times st1, data x)
  t2    = st2, x2 = y,    # second series (times st2, data y)
stop.on.error = FALSE, 
subdivisions=4000, rel.tol=1e-8, abs.tol=1e-8,
)$value
# Ixy: integral of the cross-spectrum between series 1 and 2:
#   Ixy = ∫_{f_min}^{f_max_xy} S_xy(f) df
# This captures how much shared spectral power / covariance there is
# between the two light curves over the frequency band [f_min, f_max_xy].
## -----------------------------------------------------------
## Jensen-type spectral divergence between the two series
## -----------------------------------------------------------
J <- beta * (Ix + Iy - 2 * Ixy) / (2 * pi)
# J is a scalar divergence-like measure between the two series in the
# spectral domain. The structure:
#   Ix + Iy - 2 * Ixy
# resembles:
#   ∫ [S_xx(f) + S_yy(f) - 2 S_xy(f)] df
# which is related to the energy of the difference between spectra.
# The factor beta = alpha(1 - alpha) (with alpha = 0.5) and division by 2π
# are normalization / scaling constants consistent with the chosen
# spectral definitions.
# Intuitively, higher J means the two time series have more different
# spectral content (less similarity), lower J means they are more similar.
J
# Print the final scalar spectral distance / divergence value
Ix
Iy
Ixy
J
## -----------------------------------------------------------
## Load custom functions for spectral and cross-spectral analysis
## (each of these .r files defines one or more functions used below)
## -----------------------------------------------------------
source("cross.phase.spectrum.r")          # functions for cross-phase spectrum
source("cross.amplitude.spectrum.r")      # functions for cross-amplitude spectrum
source("amplitude.spectrum.r")            # functions for (auto) amplitude spectrum
source("tau.r")                           # auxiliary function(s), e.g. lag/tau calculations
source("squared.coherence.spectrum.r")    # functions for squared coherence spectrum
source("phase.spectrum.r")                # functions for phase spectrum
source("periodogram.phase.component.r")   # functions for phase component of periodogram
source("periodogram.component.r")         # functions for periodogram of a single series
source("cross.spectrum.r")                # main cross-spectrum estimator for two series
source("power.spectrum.r")                # power spectrum / auto-spectrum functions
source("cross.spec.mtls.r")               # multitaper / MTLS-based cross-spectrum estimator
source("safe_integrate.r")
## -----------------------------------------------------------
## Load and plot the first light curve (irregularly sampled)
## -----------------------------------------------------------
Irrlyr1 <- read.delim("OGLE-BLG-RRLYR-00001.dat", sep = "")
# Irrlyr1 <- read.delim(OGLE-BLG-LPV-000009.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-BLG-LPV-000018.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-BLG-LPV-000024.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-CEP-0002.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-CEP-0005.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-CEP-0008.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-CEP-0011.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-RRLYR-00002.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-RRLYR-00003.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-RRLYR-00004.dat", sep = "")
# Irrlyr1 <- read.delim("OGLE-LMC-RRLYR-00005.dat", sep = "")
# Irrlyr1 is a data frame:
#   column 1: time (e.g. HJD or MJD)
#   column 2: magnitude
#   column 3: magnitude error
plot(Irrlyr1[, 1], Irrlyr1[, 2], type = "o")
# Quick visualization of the first RR Lyrae light curve:
# x-axis: time, y-axis: magnitude, points connected with lines ("o")
## -----------------------------------------------------------
## Load and plot the second light curve
## -----------------------------------------------------------
Irrlyr2 <- read.delim("OGLE-BLG-RRLYR-00003.dat", sep = "")
# Same structure as Irrlyr1 but for a second star (or band)
plot(Irrlyr2[, 1], Irrlyr2[, 2], type = "o")
# Visual check of the second series
## -----------------------------------------------------------
## Global spectral parameters: mixture weight and frequency grid
## -----------------------------------------------------------
alpha <- 0.5
# alpha is a mixing parameter used in Jensen-type spectral divergence
beta  <- alpha * (1 - alpha)
# beta = alpha * (1 - alpha) = 0.25 for alpha = 0.5
# This factor appears in the Jensen-type divergence between spectra
st <- Irrlyr1[, 1]
# st: time vector for series 1 (first light curve)
delta.t <- (sort(st)[length(st)] - sort(st)[1]) / length(st)
# Approximate average sampling interval Δt:
#   Δt ≈ (t_max - t_min) / N
# Using sorted times to get min and max
delta.f <- 0.001
# Frequency resolution / step Δf for evaluating the spectrum
f.min <- delta.f
# Smallest frequency evaluated: we start at Δf instead of 0
# (avoid the exact zero-frequency bin)
f.max <- 1 / (2 * delta.t)
# Maximum frequency f_max ≈ 1 / (2 * Δt) (Nyquist-like approximation)
f <- seq(f.min, f.max, delta.f)
# Frequency grid: f_min, f_min + Δf, ..., f_max
# This will be used for evaluating auto- and cross-spectra
omega <- 2 * pi * f
# Angular frequency grid: ω = 2πf
## -----------------------------------------------------------
## Define the two time series and approximate sampling
## -----------------------------------------------------------
# series 1
x   <- Irrlyr1[, 2]    # magnitudes of first light curve
st1 <- Irrlyr1[, 1]    # corresponding times of first light curve
delta.t1 <- (max(st1) - min(st1)) / length(st1)
# Approximate average sampling interval for series 1
# (not used directly below, but kept for completeness / diagnostics)
# series 2
y   <- Irrlyr2[, 2]    # magnitudes of second light curve
st2 <- Irrlyr2[, 1]    # corresponding times of second light curve
delta.t2 <- (max(st2) - min(st2)) / length(st2)
# Approximate average sampling interval for series 2
## -----------------------------------------------------------
## Auto-spectra (power or cross-spectrum with itself)
## -----------------------------------------------------------
sx1 <- cross.spectrum(st1, x, st1, x, omega)
# sx1: cross-spectrum of series 1 with itself (i.e. auto-spectrum)
# arguments:
#   t1 = st1, x1 = x -> first series
#   t2 = st1, x2 = x -> same series
#   omega         -> angular frequency grid
# Result is typically complex-valued as a function of ω
cross_spectrum_f <- function(f, t1, x1, t2, x2, demeaned=FALSE, standardized=FALSE) {
  omega <- 2*pi*f
  cross.spectrum(t1, x1, t2, x2, omega, demeaned=demeaned, standardized=standardized)
}
Ix <- integrate(
  cross_spectrum_f,
  lower = f.min,
  upper = f.max,
  t1    = st1, x1 = x,
  t2    = st1, x2 = x
)$value
# Ix: integral over frequency of the auto-spectrum of series 1
#   Ix = ∫_{f_min}^{f_max} S_xx(f) df
# Numerically computed via integrate(), using cross.spectrum as integrand.
sx2 <- cross.spectrum(st2, y, st2, y, omega)
# sx2: cross-spectrum of series 2 with itself (auto-spectrum for y)
Iy <- integrate(
  cross_spectrum_f,
  lower = f.min,
  upper = f.max,
  t1    = st2, x1 = y,
  t2    = st2, x2 = y
)$value
# Iy: integral over frequency of the auto-spectrum of series 2
#   Iy = ∫_{f_min}^{f_max} S_yy(f) df
## -----------------------------------------------------------
## Cross term: cross-spectrum between series 1 and 2
## -----------------------------------------------------------
f.max.xy <- min(f.max, f.max)
# Upper limit for the cross integral.
# Here min(f.max, f.max) is simply f.max; this line is equivalent to:
#   f.max.xy <- f.max
# (You could simplify to f.max.xy <- f.max.)
Ixy <- integrate(
  cross_spectrum_f,
  lower = f.min,
  upper = f.max.xy,
  t1    = st1, x1 = x,   # first series (times st1, data x)
  t2    = st2, x2 = y,    # second series (times st2, data y)
stop.on.error = FALSE, 
subdivisions=4000, rel.tol=1e-8, abs.tol=1e-8,
)$value
# Ixy: integral of the cross-spectrum between series 1 and 2:
#   Ixy = ∫_{f_min}^{f_max_xy} S_xy(f) df
# This captures how much shared spectral power / covariance there is
# between the two light curves over the frequency band [f_min, f_max_xy].
## -----------------------------------------------------------
## Jensen-type spectral divergence between the two series
## -----------------------------------------------------------
J <- beta * (Ix + Iy - 2 * Ixy) / (2 * pi)
# J is a scalar divergence-like measure between the two series in the
# spectral domain. The structure:
#   Ix + Iy - 2 * Ixy
# resembles:
#   ∫ [S_xx(f) + S_yy(f) - 2 S_xy(f)] df
# which is related to the energy of the difference between spectra.
# The factor beta = alpha(1 - alpha) (with alpha = 0.5) and division by 2π
# are normalization / scaling constants consistent with the chosen
# spectral definitions.
# Intuitively, higher J means the two time series have more different
# spectral content (less similarity), lower J means they are more similar.
J
# Print the final scalar spectral distance / divergence value
q()
